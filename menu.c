#include "menu.h"

// Defini√ß√£o das vari√°veis globais (aloca√ß√£o de mem√≥ria real)
nivel_caminho caminho_atual[MAX_CAMINHO_DEPTH];
int profundidade_atual = 0;
char caminho_string[MAX_CAMINHO_STR];

// Vari√°veis globais para o menu
particao sistema;
int diretorio_atual;
bool sistema_inicializado = false;
bool modo_verboso = true;


// Fun√ß√£o para limpar o buffer de entrada
void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Fun√ß√£o para pausar e aguardar entrada do usu√°rio
void pausar() {
    printf("\nPressione Enter para continuar...");
    getchar();
}

// Fun√ß√£o para encontrar o nome de um diret√≥rio pelo seu i-node
// Busca no diret√≥rio pai (se n√£o for a raiz)
char* obterNomeDiretorio(particao* p, int inode_alvo) {
    static char nome_encontrado[MAX_NOME + 1];
    
    // Se √© a raiz, retorna "/"
    if (inode_alvo == 0) {
        strcpy(nome_encontrado, "/");
        return nome_encontrado;
    }
    
    // Busca em todos os diret√≥rios para encontrar onde este i-node est√° referenciado
    for (int dir_inode = 0; dir_inode < p->numInodes; dir_inode++) {
        if (p->bitmapInodes[dir_inode] == 1 && p->inodes[dir_inode].tipo == 1) {
            // Este √© um diret√≥rio v√°lido, vamos verificar suas entradas
            int bloco_dados = p->inodes[dir_inode].blocos_diretos[0];
            if (bloco_dados != -1) {
                entrada_diretorio* entradas = (entrada_diretorio*)p->blocos[bloco_dados];
                int max_entradas = p->tamanhoBloco / sizeof(entrada_diretorio);
                
                for (int i = 0; i < max_entradas; i++) {
                    if (entradas[i].numero_inode == inode_alvo && strlen(entradas[i].nome) > 0) {
                        strcpy(nome_encontrado, entradas[i].nome);
                        return nome_encontrado;
                    }
                }
            }
        }
    }
    
    // Se n√£o encontrou, retorna uma identifica√ß√£o pelo i-node
    sprintf(nome_encontrado, "inode_%d", inode_alvo);
    return nome_encontrado;
}



// Fun√ß√£o para construir a string do caminho atual
void construirCaminhoString() {
    if (profundidade_atual == 0) {
        strcpy(caminho_string, "/");
        return;
    }
    
    strcpy(caminho_string, "");
    for (int i = 0; i < profundidade_atual; i++) {
        strcat(caminho_string, "/");
        strcat(caminho_string, caminho_atual[i].nome);
    }
}

// Fun√ß√£o para exibir o caminho atual
void exibirCaminhoAtual() {
    construirCaminhoString();
    if (profundidade_atual == 0) {
        printf("üìÅ Localiza√ß√£o atual: / (raiz)\n");
    } else {
        printf("üìÅ Localiza√ß√£o atual: %s\n", caminho_string);
    }
}

// Fun√ß√£o para navegar para um diret√≥rio (atualiza o caminho)
int navegarPara(particao* p, const char* nome_diretorio) {
    if (strcmp(nome_diretorio, "..") == 0) {
        // Voltar um n√≠vel
        if (profundidade_atual > 0) {
            profundidade_atual--;
            diretorio_atual = (profundidade_atual == 0) ? 0 : caminho_atual[profundidade_atual - 1].inode;
        } else {
            diretorio_atual = 0; // J√° est√° na raiz
        }
        return 0; // Sucesso
    }
    
    // Buscar o diret√≥rio no diret√≥rio atual
    int inode_destino = buscarEntradaDiretorio(p, diretorio_atual, nome_diretorio);
    
    if (inode_destino != -1 && p->inodes[inode_destino].tipo == 1) {
        // Adicionar ao caminho
        if (profundidade_atual < MAX_CAMINHO_DEPTH - 1) {
            caminho_atual[profundidade_atual].inode = inode_destino;
            strcpy(caminho_atual[profundidade_atual].nome, nome_diretorio);
            profundidade_atual++;
            diretorio_atual = inode_destino;
            return 0; // Sucesso
        } else {
            return -2; // Caminho muito profundo
        }
    }
    
    return -1; // Diret√≥rio n√£o encontrado
}

// Fun√ß√£o para inicializar o sistema de caminho
void inicializarSistemaCaminho() {
    profundidade_atual = 0;
    diretorio_atual = 0;
    memset(caminho_atual, 0, sizeof(caminho_atual));
    strcpy(caminho_string, "/");
}

// Fun√ß√£o para navegar para a raiz
void irParaRaiz() {
    profundidade_atual = 0;
    diretorio_atual = 0;
}

// Fun√ß√£o para obter o caminho atual como string
const char* obterCaminhoAtual() {
    construirCaminhoString();
    return caminho_string;
}

void menuNavegacao() {
    char nome[MAX_NOME + 1];
    
    printf("\nüîÑ Navegar para diret√≥rio\n");
    printf("Digite:\n");
    printf("  ‚Ä¢ Nome do diret√≥rio para entrar\n");
    printf("  ‚Ä¢ '..' para voltar um n√≠vel\n");
    printf("  ‚Ä¢ '/' para ir √† raiz\n");
    printf("Op√ß√£o: ");
    
    fgets(nome, sizeof(nome), stdin);
    nome[strcspn(nome, "\n")] = 0;
    
    if (strlen(nome) == 0) {
        printf("‚ùå Nome inv√°lido.\n");
        return;
    }
    
    if (strcmp(nome, "/") == 0) {
        irParaRaiz();
        printf("‚úÖ Voltou para o diret√≥rio raiz.\n");
        return;
    }
    
    int resultado = navegarPara(&sistema, nome);
    
    switch (resultado) {
        case 0:
            if (strcmp(nome, "..") == 0) {
                printf("‚úÖ Voltou um n√≠vel no diret√≥rio.\n");
            } else {
                printf("‚úÖ Navegou para o diret√≥rio '%s'.\n", nome);
            }
            break;
        case -1:
            printf("‚ùå Diret√≥rio '%s' n√£o encontrado.\n", nome);
            break;
        case -2:
            printf("‚ùå Caminho muito profundo (m√°ximo %d n√≠veis).\n", MAX_CAMINHO_DEPTH);
            break;
        default:
            printf("‚ùå Erro desconhecido na navega√ß√£o.\n");
    }
}

// Fun√ß√£o para mostrar navega√ß√£o com breadcrumb
void exibirCaminhoComBreadcrumb() {
    construirCaminhoString();
    
    printf("üìÅ Localiza√ß√£o: %s", caminho_string);
    
    if (profundidade_atual > 0) {
        printf(" (n√≠vel %d)", profundidade_atual);
    }
    
    printf("\n");
    
    // Mostrar breadcrumb naveg√°vel (opcional)
    if (profundidade_atual > 1) {
        printf("üí° Dica: Use '..' para voltar ou '/' para ir √† raiz\n");
    }
}

// Fun√ß√£o para resolver um caminho completo e retornar o i-node correspondente
// Retorna -1 se o caminho n√£o for v√°lido ou n√£o existir
int resolverCaminhoCompleto(particao* p, const char* caminho) {
    if (!caminho || strlen(caminho) == 0) {
        return -1;
    }
    
    // Se o caminho √© apenas "/", retorna a raiz
    if (strcmp(caminho, "/") == 0) {
        return 0;
    }
    
    // Se n√£o come√ßa com "/", √© um caminho relativo - n√£o suportado por enquanto
    if (caminho[0] != '/') {
        return -1;
    }
    
    // Copia o caminho para manipula√ß√£o
    char caminho_trabalho[256];
    strcpy(caminho_trabalho, caminho);
    
    // Remove '/' no final se existir (exceto se for apenas "/")
    int len = strlen(caminho_trabalho);
    if (len > 1 && caminho_trabalho[len - 1] == '/') {
        caminho_trabalho[len - 1] = '\0';
    }
    
    int inode_atual = 0; // Come√ßar na raiz
    
    // Dividir o caminho em componentes
    char* token = strtok(caminho_trabalho + 1, "/"); // +1 para pular o primeiro "/"
    
    while (token != NULL) {
        // Buscar o pr√≥ximo componente no diret√≥rio atual
        int proximo_inode = buscarEntradaDiretorio(p, inode_atual, token);
        
        if (proximo_inode == -1) {
            // Componente n√£o encontrado
            return -1;
        }
        
        // Verificar se √© um diret√≥rio (necess√°rio para continuar navegando)
        if (p->inodes[proximo_inode].tipo != 1) {
            // N√£o √© um diret√≥rio, mas ainda h√° mais componentes no caminho
            if (strtok(NULL, "/") != NULL) {
                return -1; // Erro: tentando navegar atrav√©s de um arquivo
            }
            // √â o √∫ltimo componente e √© um arquivo - isso √© v√°lido
            return proximo_inode;
        }
        
        inode_atual = proximo_inode;
        token = strtok(NULL, "/");
    }
    
    return inode_atual;
}

// Fun√ß√£o para verificar se um caminho √© v√°lido e se refere a um diret√≥rio
bool verificarCaminhoEDiretorio(particao* p, const char* caminho) {
    int inode = resolverCaminhoCompleto(p, caminho);
    if (inode == -1) {
        return false;
    }
    return p->inodes[inode].tipo == 1; // 1 = diret√≥rio
}

// Fun√ß√£o para obter sugest√µes de caminhos (para autocompletar ou ajudar o usu√°rio)
void mostrarSugestoesCaminhos(particao* p, int inode_base, const char* prefixo_caminho) {
    printf("üí° Diret√≥rios dispon√≠veis:\n");
    
    // Mostrar conte√∫do do diret√≥rio base
    int bloco_dados = p->inodes[inode_base].blocos_diretos[0];
    if (bloco_dados != -1) {
        entrada_diretorio* entradas = (entrada_diretorio*)p->blocos[bloco_dados];
        int max_entradas = p->tamanhoBloco / sizeof(entrada_diretorio);
        
        for (int i = 0; i < max_entradas; i++) {
            if (entradas[i].numero_inode != -1 && strlen(entradas[i].nome) > 0) {
                int inode_entrada = entradas[i].numero_inode;
                if (p->inodes[inode_entrada].tipo == 1) { // Apenas diret√≥rios
                    printf("   %s%s/\n", prefixo_caminho, entradas[i].nome);
                }
            }
        }
    }
}

// Vers√£o melhorada da fun√ß√£o de mover arquivo que aceita caminhos
int moverArquivoComCaminho(particao* p, int inode_dir_origem, const char* nome_arquivo, const char* caminho_destino) {
    // Primeiro, verificar se o arquivo existe no diret√≥rio de origem
    int inode_arquivo = buscarEntradaDiretorio(p, inode_dir_origem, nome_arquivo);
    if (inode_arquivo == -1) {
        printf("‚ùå Arquivo '%s' n√£o encontrado no diret√≥rio atual.\n", nome_arquivo);
        return -1;
    }
    
    // Verificar se √© realmente um arquivo
    if (p->inodes[inode_arquivo].tipo != 0) {
        printf("‚ùå '%s' n√£o √© um arquivo.\n", nome_arquivo);
        return -1;
    }
    
    // Resolver o caminho de destino
    int inode_destino = resolverCaminhoCompleto(p, caminho_destino);
    if (inode_destino == -1) {
        printf("‚ùå Caminho de destino '%s' n√£o encontrado.\n", caminho_destino);
        printf("üí° Certifique-se de que o caminho existe e est√° correto.\n");
        printf("   Exemplo: /diretorio1/subdiretorio\n");
        return -1;
    }
    
    // Verificar se o destino √© um diret√≥rio
    if (p->inodes[inode_destino].tipo != 1) {
        printf("‚ùå O destino '%s' n√£o √© um diret√≥rio.\n", caminho_destino);
        return -1;
    }
    
    // Verificar se j√° existe um arquivo com o mesmo nome no destino
    if (buscarEntradaDiretorio(p, inode_destino, nome_arquivo) != -1) {
        printf("‚ùå J√° existe um arquivo com o nome '%s' no destino.\n", nome_arquivo);
        return -1;
    }
    
    // Usar a fun√ß√£o original de mover arquivo
    int resultado = moverArquivo(p, inode_dir_origem, nome_arquivo, inode_destino);
    
    if (resultado == 0) {
        printf("‚úÖ Arquivo '%s' movido para '%s' com sucesso!\n", nome_arquivo, caminho_destino);
    }
    
    return resultado;
}

// Fun√ß√£o para navegar usando caminho completo (atualiza o estado global)
int navegarParaCaminhoCompleto(particao* p, const char* caminho) {
    if (!caminho || strlen(caminho) == 0) {
        return -1;
    }
    
    // Resolver o caminho
    int inode_destino = resolverCaminhoCompleto(p, caminho);
    if (inode_destino == -1) {
        return -1; // Caminho n√£o encontrado
    }
    
    // Verificar se √© um diret√≥rio
    if (p->inodes[inode_destino].tipo != 1) {
        return -2; // N√£o √© um diret√≥rio
    }
    
    // Atualizar o estado global de navega√ß√£o
    if (strcmp(caminho, "/") == 0) {
        // Ir para a raiz
        irParaRaiz();
        return 0;
    }
    
    // Reconstruir o caminho atual baseado no caminho fornecido
    char caminho_trabalho[256];
    strcpy(caminho_trabalho, caminho);
    
    // Remove '/' no final se existir
    int len = strlen(caminho_trabalho);
    if (len > 1 && caminho_trabalho[len - 1] == '/') {
        caminho_trabalho[len - 1] = '\0';
    }
    
    // Resetar o caminho atual
    profundidade_atual = 0;
    diretorio_atual = 0;
    
    // Navegar componente por componente
    char* token = strtok(caminho_trabalho + 1, "/");
    
    while (token != NULL) {
        int resultado = navegarPara(p, token);
        if (resultado != 0) {
            return resultado;
        }
        token = strtok(NULL, "/");
    }
    
    return 0;
}

// Vers√£o atualizada do case 7 no menu de arquivos
void menuMoverArquivoAtualizado() {
    char nome[MAX_NOME + 1], caminho_destino[256];
    int opcao_entrada;
    
    printf("\nüîÑ Mover arquivo\n");
    printf("Nome do arquivo: ");
    fgets(nome, sizeof(nome), stdin);
    nome[strcspn(nome, "\n")] = 0;
    
    printf("\nEscolha como especificar o destino:\n");
    printf("1. üìÅ Caminho completo (ex: /docs/imagens)\n");
    printf("2. üÜî I-node do diret√≥rio (m√©todo antigo)\n");
    printf("Op√ß√£o: ");
    
    if (scanf("%d", &opcao_entrada) != 1) {
        printf("‚ùå Op√ß√£o inv√°lida!\n");
        limparBuffer();
        return;
    }
    limparBuffer();
    
    if (opcao_entrada == 1) {
        // Usar caminho completo
        printf("Caminho do diret√≥rio destino: ");
        fgets(caminho_destino, sizeof(caminho_destino), stdin);
        caminho_destino[strcspn(caminho_destino, "\n")] = 0;
        
        // Mostrar alguns diret√≥rios dispon√≠veis como sugest√£o
        printf("\nüí° Alguns diret√≥rios dispon√≠veis a partir da raiz:\n");
        mostrarSugestoesCaminhos(&sistema, 0, "/");
        
        if (modo_verboso) {
            printf("‚è≥ Movendo arquivo '%s' para '%s'...\n", nome, caminho_destino);
        }
        
        moverArquivoComCaminho(&sistema, diretorio_atual, nome, caminho_destino);
        
    } else if (opcao_entrada == 2) {
        // Usar i-node (m√©todo antigo)
        int inode_destino;
        printf("I-node do diret√≥rio destino (0 = raiz): ");
        if (scanf("%d", &inode_destino) != 1) {
            printf("‚ùå I-node inv√°lido!\n");
            limparBuffer();
            return;
        }
        limparBuffer();
        
        if (modo_verboso) {
            printf("‚è≥ Movendo arquivo '%s'...\n", nome);
        }
        
        if (moverArquivo(&sistema, diretorio_atual, nome, inode_destino) == 0) {
            printf("‚úÖ Arquivo movido com sucesso!\n");
        } else {
            printf("‚ùå Falha ao mover arquivo.\n");
        }
    } else {
        printf("‚ùå Op√ß√£o inv√°lida!\n");
    }
}

// Fun√ß√£o adicional para navega√ß√£o avan√ßada no menu
void menuNavegacaoAvancada() {
    char entrada[256];
    int opcao;
    
    printf("\nüîÑ Navega√ß√£o Avan√ßada\n");
    printf("1. üìÅ Navegar usando caminho completo\n");
    printf("2. üìã Navegar usando nome do diret√≥rio (atual)\n");
    printf("Op√ß√£o: ");
    
    if (scanf("%d", &opcao) != 1) {
        printf("‚ùå Op√ß√£o inv√°lida!\n");
        limparBuffer();
        return;
    }
    limparBuffer();
    
    if (opcao == 1) {
        printf("Digite o caminho completo (ex: /docs/imagens): ");
        fgets(entrada, sizeof(entrada), stdin);
        entrada[strcspn(entrada, "\n")] = 0;
        
        if (strlen(entrada) == 0) {
            printf("‚ùå Caminho inv√°lido.\n");
            return;
        }
        
        int resultado = navegarParaCaminhoCompleto(&sistema, entrada);
        
        switch (resultado) {
            case 0:
                printf("‚úÖ Navegou para '%s' com sucesso.\n", entrada);
                break;
            case -1:
                printf("‚ùå Caminho '%s' n√£o encontrado.\n", entrada);
                break;
            case -2:
                printf("‚ùå '%s' n√£o √© um diret√≥rio.\n", entrada);
                break;
            default:
                printf("‚ùå Erro desconhecido na navega√ß√£o.\n");
        }
    } else if (opcao == 2) {
        // Usar a fun√ß√£o de navega√ß√£o original
        menuNavegacao();
    } else {
        printf("‚ùå Op√ß√£o inv√°lida!\n");
    }
}

// Fun√ß√£o para inicializar o sistema
void menuInicializarSistema() {
    int tamanho, tamanhoBloco;
    
    printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    printf("üöÄ INICIALIZA√á√ÉO DO SISTEMA DE ARQUIVOS\n");
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    printf("üìã Configura√ß√µes recomendadas:\n");
    printf("   ‚Ä¢ Tamanho da parti√ß√£o: 8192-65536 bytes\n");
    printf("   ‚Ä¢ Tamanho do bloco: 512-1024 bytes\n\n");
    
    do {
        printf("üíæ Digite o tamanho da parti√ß√£o (em bytes): ");
        if (scanf("%d", &tamanho) != 1) {
            printf("‚ùå Erro: Digite um n√∫mero v√°lido.\n");
            limparBuffer();
            continue;
        }
        limparBuffer();
        
        if (tamanho < 1024 || tamanho > 1000000) {
            printf("‚ö†Ô∏è  Aviso: Tamanho fora da faixa recomendada.\n");
        }
        break;
    } while (1);
    
    do {
        printf("üîß Digite o tamanho do bloco (em bytes): ");
        if (scanf("%d", &tamanhoBloco) != 1) {
            printf("‚ùå Erro: Digite um n√∫mero v√°lido.\n");
            limparBuffer();
            continue;
        }
        limparBuffer();
        
        if (tamanho % tamanhoBloco != 0) {
            printf("‚ùå Erro: O tamanho da parti√ß√£o deve ser m√∫ltiplo do tamanho do bloco.\n");
            continue;
        }
        break;
    } while (1);
    
    printf("\n‚è≥ Inicializando sistema de arquivos...\n");
    
    if (inicializarParticao(&sistema, tamanho, tamanhoBloco) == 0) {
        sistema_inicializado = true;
        inicializarSistemaCaminho();
        diretorio_atual = 0; // Come√ßar na raiz
        printf("‚úÖ Sistema inicializado com sucesso!\n");
        mostrarEstatisticas(&sistema);
    } else {
        printf("‚ùå Falha na inicializa√ß√£o do sistema.\n");
    }
    
    pausar();
}

// Menu para opera√ß√µes com diret√≥rios
void menuDiretorios() {
    int opcao;
    char nome[MAX_NOME + 1], nome_novo[MAX_NOME + 1];
    
    do {
        printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("üìÅ OPERA√á√ïES COM DIRET√ìRIOS\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        exibirCaminhoAtual();
        printf("\n1. üìã Listar conte√∫do do diret√≥rio atual\n");
        printf("2. ‚ûï Criar novo diret√≥rio\n");
        printf("3. ‚úèÔ∏è  Renomear diret√≥rio\n");
        printf("4. üóëÔ∏è  Apagar diret√≥rio\n");
        printf("5. üîÑ Navegar para diret√≥rio\n");
        printf("0. ‚¨ÖÔ∏è  Voltar ao menu principal\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("Escolha uma op√ß√£o: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("‚ùå Op√ß√£o inv√°lida!\n");
            limparBuffer();
            continue;
        }
        limparBuffer();
        
        switch (opcao) {
            case 1:
                printf("\nüìã Conte√∫do do diret√≥rio:\n");
                listarDiretorio(&sistema, diretorio_atual);
                pausar();
                break;
                
            case 2:
                printf("\n‚ûï Criar novo diret√≥rio\n");
                printf("Digite o nome do diret√≥rio: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0; // Remove newline
                
                if (modo_verboso) {
                    printf("‚è≥ Criando diret√≥rio '%s'...\n", nome);
                }
                
                if (criarDiretorio(&sistema, nome, diretorio_atual) != -1) {
                    printf("‚úÖ Diret√≥rio criado com sucesso!\n");
                } else {
                    printf("‚ùå Falha ao criar diret√≥rio.\n");
                }
                pausar();
                break;
                
            case 3:
                printf("\n‚úèÔ∏è  Renomear diret√≥rio\n");
                printf("Nome atual do diret√≥rio: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                printf("Novo nome: ");
                fgets(nome_novo, sizeof(nome_novo), stdin);
                nome_novo[strcspn(nome_novo, "\n")] = 0;
                
                if (modo_verboso) {
                    printf("‚è≥ Renomeando '%s' para '%s'...\n", nome, nome_novo);
                }
                
                if (renomearEntrada(&sistema, diretorio_atual, nome, nome_novo) == 0) {
                    printf("‚úÖ Diret√≥rio renomeado com sucesso!\n");
                } else {
                    printf("‚ùå Falha ao renomear diret√≥rio.\n");
                }
                pausar();
                break;
                
            case 4:
                printf("\nüóëÔ∏è  Apagar diret√≥rio\n");
                printf("‚ö†Ô∏è  ATEN√á√ÉO: Esta opera√ß√£o √© irrevers√≠vel!\n");
                printf("Nome do diret√≥rio a apagar: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                printf("Tem certeza? (s/N): ");
                char confirmacao;
                scanf("%c", &confirmacao);
                limparBuffer();
                
                if (confirmacao == 's' || confirmacao == 'S') {
                    if (modo_verboso) {
                        printf("‚è≥ Apagando diret√≥rio '%s'...\n", nome);
                    }
                    
                    if (apagarDiretorio(&sistema, diretorio_atual, nome) == 0) {
                        printf("‚úÖ Diret√≥rio apagado com sucesso!\n");
                    } else {
                        printf("‚ùå Falha ao apagar diret√≥rio.\n");
                    }
                } else {
                    printf("‚ùå Opera√ß√£o cancelada.\n");
                }
                pausar();
                break;
                
            case 5:
                menuNavegacaoAvancada();
                pausar();
                break;
                
            case 0:
                break;
                
            default:
                printf("‚ùå Op√ß√£o inv√°lida!\n");
                pausar();
        }
    } while (opcao != 0);
}

// Menu para opera√ß√µes com arquivos
void menuArquivos() {
    int opcao;
    char nome[MAX_NOME + 1], nome_novo[MAX_NOME + 1], caminho[256];
    
    do {
        printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("üìÑ OPERA√á√ïES COM ARQUIVOS\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        exibirCaminhoAtual();
        printf("\n1. üìã Listar arquivos do diret√≥rio atual\n");
        printf("2. ‚ûï Criar arquivo vazio\n");
        printf("3. üì• Importar arquivo do sistema\n");
        printf("4. üëÅÔ∏è  Visualizar conte√∫do do arquivo\n");
        printf("5. ‚ÑπÔ∏è  Informa√ß√µes detalhadas do arquivo\n");
        printf("6. ‚úèÔ∏è  Renomear arquivo\n");
        printf("7. üîÑ Mover arquivo\n");
        printf("8. üóëÔ∏è  Apagar arquivo\n");
        printf("9. üîç Buscar arquivo (recursivo)\n");
        printf("0. ‚¨ÖÔ∏è  Voltar ao menu principal\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("Escolha uma op√ß√£o: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("‚ùå Op√ß√£o inv√°lida!\n");
            limparBuffer();
            continue;
        }
        limparBuffer();
        
        switch (opcao) {
            case 1:
                printf("\nüìã Arquivos no diret√≥rio atual:\n");
                listarDiretorio(&sistema, diretorio_atual);
                pausar();
                break;
                
            case 2:
                printf("\n‚ûï Criar arquivo vazio\n");
                printf("Nome do arquivo: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                if (modo_verboso) {
                    printf("‚è≥ Criando arquivo '%s'...\n", nome);
                }
                
                if (criarArquivo(&sistema, nome, diretorio_atual) != -1) {
                    printf("‚úÖ Arquivo criado com sucesso!\n");
                } else {
                    printf("‚ùå Falha ao criar arquivo.\n");
                }
                pausar();
                break;
                
            case 3:
                printf("\nüì• Importar arquivo do sistema\n");
                printf("Nome do arquivo no simulador: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                printf("Caminho do arquivo real: ");
                fgets(caminho, sizeof(caminho), stdin);
                caminho[strcspn(caminho, "\n")] = 0;
                
                // Criar arquivo primeiro
                int inode_arquivo = criarArquivo(&sistema, nome, diretorio_atual);
                if (inode_arquivo != -1) {
                    if (modo_verboso) {
                        printf("‚è≥ Importando conte√∫do de '%s'...\n", caminho);
                    }
                    
                    if (importarArquivo(&sistema, inode_arquivo, caminho) == 0) {
                        printf("‚úÖ Arquivo importado com sucesso!\n");
                    } else {
                        printf("‚ùå Falha ao importar conte√∫do do arquivo.\n");
                    }
                } else {
                    printf("‚ùå Falha ao criar arquivo no simulador.\n");
                }
                pausar();
                break;
                
            case 4:
                printf("\nüëÅÔ∏è  Visualizar conte√∫do do arquivo\n");
                printf("Nome do arquivo: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                int inode_vis = buscarEntradaDiretorio(&sistema, diretorio_atual, nome);
                if (inode_vis != -1 && sistema.inodes[inode_vis].tipo == 0) {
                    listarConteudoArquivo(&sistema, inode_vis);
                } else {
                    printf("‚ùå Arquivo n√£o encontrado.\n");
                }
                pausar();
                break;
                
            case 5:
                printf("\n‚ÑπÔ∏è  Informa√ß√µes detalhadas do arquivo\n");
                printf("Nome do arquivo: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                int inode_info = buscarEntradaDiretorio(&sistema, diretorio_atual, nome);
                if (inode_info != -1 && sistema.inodes[inode_info].tipo == 0) {
                    informacoesArquivo(&sistema, inode_info);
                } else {
                    printf("‚ùå Arquivo n√£o encontrado.\n");
                }
                pausar();
                break;
                
            case 6:
                printf("\n‚úèÔ∏è  Renomear arquivo\n");
                printf("Nome atual: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                printf("Novo nome: ");
                fgets(nome_novo, sizeof(nome_novo), stdin);
                nome_novo[strcspn(nome_novo, "\n")] = 0;
                
                if (modo_verboso) {
                    printf("‚è≥ Renomeando '%s' para '%s'...\n", nome, nome_novo);
                }
                
                if (renomearArquivo(&sistema, diretorio_atual, nome, nome_novo) == 0) {
                    printf("‚úÖ Arquivo renomeado com sucesso!\n");
                } else {
                    printf("‚ùå Falha ao renomear arquivo.\n");
                }
                pausar();
                break;
                
            case 7:
                menuMoverArquivoAtualizado();
                pausar();
                break;
                            
            case 8:
                printf("\nüóëÔ∏è  Apagar arquivo\n");
                printf("‚ö†Ô∏è  ATEN√á√ÉO: Esta opera√ß√£o √© irrevers√≠vel!\n");
                printf("Nome do arquivo: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                printf("Tem certeza? (s/N): ");
                char conf;
                scanf("%c", &conf);
                limparBuffer();
                
                if (conf == 's' || conf == 'S') {
                    if (modo_verboso) {
                        printf("‚è≥ Apagando arquivo '%s'...\n", nome);
                    }
                    
                    if (apagarArquivo(&sistema, diretorio_atual, nome) == 0) {
                        printf("‚úÖ Arquivo apagado com sucesso!\n");
                    } else {
                        printf("‚ùå Falha ao apagar arquivo.\n");
                    }
                } else {
                    printf("‚ùå Opera√ß√£o cancelada.\n");
                }
                pausar();
                break;
                
            case 9:
                printf("\nüîç Buscar arquivo (recursivo)\n");
                printf("Nome do arquivo: ");
                fgets(nome, sizeof(nome), stdin);
                nome[strcspn(nome, "\n")] = 0;
                
                if (modo_verboso) {
                    printf("‚è≥ Buscando arquivo '%s'...\n", nome);
                }
                
                int resultado = buscarArquivoRecursivo(&sistema, 0, nome); // Buscar a partir da raiz
                if (resultado != -1) {
                    printf("‚úÖ Arquivo encontrado (i-node %d)!\n", resultado);
                    informacoesArquivo(&sistema, resultado);
                } else {
                    printf("‚ùå Arquivo n√£o encontrado.\n");
                }
                pausar();
                break;
                
            case 0:
                break;
                
            default:
                printf("‚ùå Op√ß√£o inv√°lida!\n");
                pausar();
        }
    } while (opcao != 0);
}

// Menu de configura√ß√µes
void menuConfiguracoes() {
    int opcao;
    
    do {
        printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("‚öôÔ∏è  CONFIGURA√á√ïES E INFORMA√á√ïES\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("1. üìä Mostrar estat√≠sticas do sistema\n");
        printf("2. üîß Alternar modo verboso (atual: %s)\n", modo_verboso ? "ATIVO" : "INATIVO");
        printf("3. üÜî Mostrar informa√ß√µes dos i-nodes\n");
        printf("4. üó∫Ô∏è  Mostrar mapa de bits\n");
        printf("5. üîÑ Reinicializar sistema\n");
        printf("0. ‚¨ÖÔ∏è  Voltar ao menu principal\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("Escolha uma op√ß√£o: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("‚ùå Op√ß√£o inv√°lida!\n");
            limparBuffer();
            continue;
        }
        limparBuffer();
        
        switch (opcao) {
            case 1:
                mostrarEstatisticas(&sistema);
                pausar();
                break;
                
            case 2:
                modo_verboso = !modo_verboso;
                printf("‚úÖ Modo verboso %s!\n", modo_verboso ? "ATIVADO" : "DESATIVADO");
                pausar();
                break;
                
            case 3:
                printf("\nüÜî Informa√ß√µes dos I-nodes:\n");
                printf("%-6s %-8s %-10s %-20s\n", "I-node", "Tipo", "Tamanho", "√öltima Modifica√ß√£o");
                printf("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n");
                
                for (int i = 0; i < sistema.numInodes; i++) {
                    if (sistema.bitmapInodes[i] == 1) {
                        char tipo_str[10];
                        if (sistema.inodes[i].tipo == 1) strcpy(tipo_str, "DIR");
                        else if (sistema.inodes[i].tipo == 0) strcpy(tipo_str, "FILE");
                        else strcpy(tipo_str, "LIVRE");
                        
                        char *time_str = ctime(&sistema.inodes[i].data_modificacao);
                        if (time_str) time_str[strlen(time_str) - 1] = '\0';
                        
                        printf("%-6d %-8s %-10d %-20s\n", 
                               i, tipo_str, sistema.inodes[i].tamanho, 
                               time_str ? time_str : "N/A");
                    }
                }
                pausar();
                break;
                
            case 4:
                printf("\nüó∫Ô∏è  Mapa de bits dos blocos (L=Livre, U=Usado):\n");
                for (int i = 0; i < sistema.numBlocos; i++) {
                    if (i % 32 == 0) printf("\nBlocos %3d-%3d: ", i, i + 31);
                    printf("%c", sistema.bitmap[i] ? 'U' : 'L');
                }
                printf("\n\nüó∫Ô∏è  Mapa de bits dos i-nodes (L=Livre, U=Usado):\n");
                for (int i = 0; i < sistema.numInodes; i++) {
                    if (i % 32 == 0) printf("\nI-nodes %2d-%2d: ", i, i + 31);
                    printf("%c", sistema.bitmapInodes[i] ? 'U' : 'L');
                }
                printf("\n");
                pausar();
                break;
                
            case 5:
                printf("\nüîÑ Reinicializar sistema\n");
                printf("‚ö†Ô∏è  ATEN√á√ÉO: Todos os dados ser√£o perdidos!\n");
                printf("Tem certeza? (s/N): ");
                char conf;
                scanf("%c", &conf);
                limparBuffer();
                
                if (conf == 's' || conf == 'S') {
                    liberarParticao(&sistema);
                    sistema_inicializado = false;
                    diretorio_atual = 0;
                    printf("‚úÖ Sistema reinicializado. Execute a inicializa√ß√£o novamente.\n");
                } else {
                    printf("‚ùå Opera√ß√£o cancelada.\n");
                }
                pausar();
                break;
                
            case 0:
                break;
                
            default:
                printf("‚ùå Op√ß√£o inv√°lida!\n");
                pausar();
        }
    } while (opcao != 0);
}

// Menu principal
void menuPrincipal() {
    int opcao;
    
    do {
        system("clear || cls"); // Limpar tela (Linux/Mac || Windows)
        
        printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
        printf("‚ïë        üóÑÔ∏è  SIMULADOR DE SISTEMA DE        ‚ïë\n");
        printf("‚ïë              ARQUIVOS v1.0               ‚ïë\n");
        printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
        
        if (sistema_inicializado) {
            printf("üü¢ Sistema INICIALIZADO\n");
            exibirCaminhoAtual();
        } else {
            printf("üî¥ Sistema N√ÉO INICIALIZADO\n");
            printf("üìÅ Execute a inicializa√ß√£o primeiro!\n");
        }
        
        printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("üìã MENU PRINCIPAL\n");
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        
        if (!sistema_inicializado) {
            printf("1. üöÄ Inicializar sistema de arquivos\n");
            printf("9. ‚ùì Sobre o simulador\n");
            printf("0. üö™ Sair\n");
        } else {
            printf("1. üöÄ Reinicializar sistema\n");
            printf("2. üìÅ Opera√ß√µes com diret√≥rios\n");
            printf("3. üìÑ Opera√ß√µes com arquivos\n");
            printf("4. ‚öôÔ∏è  Configura√ß√µes e informa√ß√µes\n");
            printf("5. ü§ñ Execu√ß√£o autom√°tica de comandos\n");
            printf("9. ‚ùì Sobre o simulador\n");
            printf("0. üö™ Sair\n");
        }
        
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("Escolha uma op√ß√£o: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("‚ùå Op√ß√£o inv√°lida!\n");
            limparBuffer();
            pausar();
            continue;
        }
        limparBuffer();
        
        switch (opcao) {
            case 1:
                if (!sistema_inicializado) {
                    menuInicializarSistema();
                } else {
                    liberarParticao(&sistema);
                    sistema_inicializado = false;
                    menuInicializarSistema();
                }
                break;
                
            case 2:
                if (sistema_inicializado) {
                    menuDiretorios();
                } else {
                    printf("‚ùå Sistema n√£o inicializado!\n");
                    pausar();
                }
                break;
                
            case 3:
                if (sistema_inicializado) {
                    menuArquivos();
                } else {
                    printf("‚ùå Sistema n√£o inicializado!\n");
                    pausar();
                }
                break;
                
            case 4:
                if (sistema_inicializado) {
                    menuConfiguracoes();
                } else {
                    printf("‚ùå Sistema n√£o inicializado!\n");
                    pausar();
                }
                break;
            case 5:
                if (sistema_inicializado) {
                    menuExecucaoAutomatica();
                } else {
                    printf("‚ùå Sistema n√£o inicializado!\n");
                    pausar();
                }
                break;
                
            case 9:
                printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
                printf("‚ïë           üìñ SOBRE O SIMULADOR            ‚ïë\n");
                printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
                printf("üîπ Simulador de Sistema de Arquivos v1.0\n");
                printf("üîπ Implementa conceitos de i-nodes e blocos\n");
                printf("üîπ Suporte a diret√≥rios e arquivos\n");
                printf("üîπ Opera√ß√µes: criar, listar, renomear, mover, apagar\n");
                printf("üîπ Importa√ß√£o de arquivos reais do sistema\n");
                printf("üîπ Busca recursiva e estat√≠sticas detalhadas\n\n");
                printf("üìã Estruturas principais:\n");
                printf("   ‚Ä¢ I-nodes: metadados dos arquivos/diret√≥rios\n");
                printf("   ‚Ä¢ Blocos: armazenamento de dados\n");
                printf("   ‚Ä¢ Bitmaps: controle de recursos livres/usados\n");
                printf("   ‚Ä¢ Entradas de diret√≥rio: mapeamento nome‚Üíi-node\n\n");
                printf("‚ö° Desenvolvido para fins educacionais\n");
                pausar();
                break;
                
            case 0:
                if (sistema_inicializado) {
                    printf("\nüîÑ Liberando recursos...\n");
                    liberarParticao(&sistema);
                }
                printf("üëã Obrigado por usar o simulador!\n");
                break;
                
            default:
                printf("‚ùå Op√ß√£o inv√°lida!\n");
                pausar();
        }
    } while (opcao != 0);
}